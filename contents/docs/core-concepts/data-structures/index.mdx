### 1. Arrays
An array is an ordered collection of elements, where each element can be accessed by its index.

Relevance:
Storing and manipulating lists of items, such as rendering a list of products or search results.
Iterating over data for rendering components (e.g., using .map() in React).
Example:
```javascript
const fruits = ['apple', 'banana', 'cherry'];

// Rendering in React
fruits.map(fruit => <li key={fruit}>{fruit}</li>);
```

### 2. Objects
Objects are collections of key-value pairs and are a fundamental way to store structured data.

Relevance:
Representing data models (e.g., user profiles, configuration settings).
Managing state in applications (e.g., using objects in useState in React).
Example:
```javascript
const user = {
  name: 'Alice',
  age: 25,
  isActive: true,
};

// Accessing properties
console.log(user.name); // Alice```
### 3. Stacks
A stack follows the Last-In-First-Out (LIFO) principle, where the last added item is the first to be removed.

Relevance:
Managing navigation history (e.g., browser back/forward functionality).
Tracking application state changes.
Example:
```javascript
const stack = [];
stack.push('Page 1');
stack.push('Page 2');
console.log(stack.pop()); // Page 2
```
### 4. Queues
A queue follows the First-In-First-Out (FIFO) principle, where the first added item is the first to be removed.

Relevance:
Handling task scheduling (e.g., animations, event loops, or background tasks).
Managing requests or API calls in a controlled manner.
Example:
```javascript
const queue = [];
queue.push('Task 1');
queue.push('Task 2');
console.log(queue.shift()); // Task 1
```
### 5. Sets
A set is a collection of unique values, which prevents duplicates.

Relevance:
Removing duplicate items from an array.
Tracking unique elements (e.g., tags, selected items).
Example:
```javascript
const set = new Set([1, 2, 2, 3]);
console.log([...set]); // [1, 2, 3]
```
### 6. Maps
A map is a collection of key-value pairs that allows any data type as a key.

Relevance:
Efficiently managing and accessing data with unique keys.
Useful when keys are not just strings (e.g., using objects or functions as keys).
Example:
```javascript
const map = new Map();
map.set('name', 'Alice');
map.set('age', 25);
console.log(map.get('name')); // Alice
```
### 7. Linked Lists
A linked list is a sequence of nodes where each node points to the next node.

Relevance:
Rarely used directly in frontend development but important for understanding other data structures (e.g., React Fiber is built using a linked list-like structure).
Efficient insertion and deletion operations.
###8. Trees
A tree is a hierarchical data structure where each node has a parent node and child nodes.

Relevance:
Representing the DOM structure in the browser.
Managing hierarchical data like file systems or menus.
Example:
```javascript
const tree = {
  value: 'root',
  children: [
    { value: 'child 1', children: [] },
    { value: 'child 2', children: [{ value: 'grandchild', children: [] }] },
  ],
};
```
### 9. Graphs
A graph is a set of nodes connected by edges.

Relevance:
Representing networks (e.g., social media connections, routing, or dependency graphs).
Implementing features like recommendation systems or navigation.
### 10. Hash Tables
A hash table is a data structure that maps keys to values for efficient lookups.

Relevance:
Fast lookups for caching and memoization.
### Storing data like dictionaries (similar to JavaScript objects or Maps).
11. Priority Queues/Heaps
A priority queue is a queue where each element has a priority, and elements with higher priority are dequeued first.

Relevance:
Managing animations and rendering tasks with different priorities.
Handling complex scheduling or sorting scenarios.